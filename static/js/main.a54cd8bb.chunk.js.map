{"version":3,"sources":["Covid-19fin2.glb","logo.svg","App.js","serviceWorker.js","index.js"],"names":["module","exports","Model","particle","console","log","gltf","useLoader","GLTFLoader","corona","loader","dracoLoader","DRACOLoader","decoderPath","setDRACOLoader","useState","geometry","setGeometry","scene","clone","group","useRef","useFrame","state","t","factor","speed","xFactor","yFactor","zFactor","time","a","Math","cos","sin","b","s","current","position","set","scale","rotation","x","y","ref","object","dispose","Models","count","Array","fill","map","_","i","modelProps","random","mx","my","extend","OrbitControls","App","camera","intensity","color","castShadow","angle","PI","shadow-mapSize-width","shadow-mapSize-height","fallback","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.a54cd8bb.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/Covid-19fin2.16698fb9.glb\";","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","import React, { useState, useRef, Suspense, useMemo } from 'react'\nimport logo from './logo.svg'\nimport './App.css'\nimport * as THREE from 'three'\nimport { Canvas, useLoader, useFrame, extend, useThree } from 'react-three-fiber'\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader'\nimport { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\nimport corona from './Covid-19fin2.glb'\nimport { Object3D } from 'three'\n\nfunction Model(particle) {\n  console.log('Model -> particle', particle)\n  const gltf = useLoader(GLTFLoader, corona, (loader) => {\n    const dracoLoader = new DRACOLoader()\n    dracoLoader.decoderPath = '/draco-gltf/'\n    loader.setDRACOLoader(dracoLoader)\n  })\n  const [geometry, setGeometry] = useState()\n\n  // init\n  if (!geometry) {\n    // Scene settings\n    const scene = gltf.scene.clone(true) // so we can instantiate multiple copies of this geometry\n    setGeometry(scene)\n  }\n  const group = useRef()\n  useFrame((state) => {\n    // Makes the light follow the mouse\n    // light.current.position.set(mouse.current[0] / aspect, -mouse.current[1] / aspect, 0)\n    // Run through the randomized data to calculate some movement\n    const { t, factor, speed, xFactor, yFactor, zFactor } = particle\n    // There is no sense or reason to any of this, just messing around with trigonometric functions\n    let time = t * 2 + speed / 2\n    const a = Math.cos(time) + Math.sin(time * 1) / 10\n    const b = Math.sin(time) + Math.cos(time * 2) / 10\n    const s = Math.cos(time)\n    // particle.mx += (mouse.current[0] - particle.mx) * 0.01\n    // particle.my += (mouse.current[1] * -1 - particle.my) * 0.01\n    // Update the dummy object\n    group.current.position.set(\n      a + xFactor + Math.cos((time / 10) * factor) + (Math.sin(time * 1) * factor) / 10,\n      b + yFactor + Math.sin((time / 10) * factor) + (Math.cos(time * 2) * factor) / 10,\n      b + zFactor + Math.cos((time / 10) * factor) + (Math.sin(time * 3) * factor) / 10\n    )\n    console.log(\"Model -> group.current\", group.current)\n    group.current.scale.set(s, s, s)\n    // group.current.rotation.set(s * 5, s * 5, s * 5)\n    group.current.rotation.x = group.current.rotation.y += 0.01\n    // group.current.updateMatrix()\n  })\n  return (\n    <group >\n      <primitive ref={group} object={geometry} dispose={null} />\n    </group>\n  )\n}\nfunction Models({ count }) {\n  // The innards of this hook will run every frame\n\n  return new Array(count).fill().map((_, i) => {\n    const t = Math.random() * 100\n    const factor = 20 + Math.random() * 100\n    const speed = 0.01 + Math.random() / 500\n    const xFactor = -50 + Math.random() * 100\n    const yFactor = -50 + Math.random() * 100\n    const zFactor = -50 + Math.random() * 100\n    const modelProps = { t, factor, speed, xFactor, yFactor, zFactor, mx: 0, my: 0 }\n\n    return <Model {...modelProps} />\n  })\n}\n\nextend({ OrbitControls })\nconst Controls = (props) => {\n  const { gl, camera } = useThree()\n  const ref = useRef()\n  useFrame(() => ref.current.update())\n  return <orbitControls ref={ref} args={[camera, gl.domElement]} {...props} />\n}\nfunction App() {\n  return (\n    <Canvas camera={{ position: [0, 0, 15] }}>\n      <ambientLight intensity={0.4} />\n      <pointLight intensity={20} position={[-10, -25, -10]} color='#200f20' />\n      <spotLight\n        castShadow\n        intensity={4}\n        angle={Math.PI / 8}\n        position={[15, 25, 5]}\n        shadow-mapSize-width={2048}\n        shadow-mapSize-height={2048}\n      />\n      <Suspense fallback={null}>\n        <Models count={20} />\n      </Suspense>\n      {/* <Controls\n        autoRotate\n        enablePan={false}\n        enableZoom={false}\n        enableDamping\n        dampingFactor={0.5}\n        rotateSpeed={1}\n        maxPolarAngle={Math.PI / 2}\n        minPolarAngle={Math.PI / 2}\n      /> */}\n    </Canvas>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}